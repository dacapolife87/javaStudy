# 목표

자바의 람다식에 대해 학습하세요.

# 학습할 것

- 람다식 사용법
- 함수형 인터페이스
- Variable Capture
- 메소드, 생성자 레퍼런스

---



### 람다식 사용법

<pre>
(파라미터목록) -> 한줄 자바코드
or
(파라미터목록) -> {자바코드문장들;}
</pre>

람다표현식으로 전환하는 과정을 살펴보자
1단계 : 익명 클래스 선언부분 제거
```java
Thread thread = new Thread(new Runnable(){
    @Override
    public void run() {
        System.out.println("Hello World");
    }
});
```

Thread생성자의 인수는 Runnable인터페이스가 유일하며, 
입력하해야 할 것이 Runnable 인터페이스 혹은 이를 구현한 클래스로 한정되기 때문에 
인터페이스명을 다시 선언할 필요가없다.

2단계 : 메서드 선언 부분제거
```java
Thread thread = new Thread(
    @Override
    public void run() {
        System.out.println("Hello World");
    }
);
```

메서드의 구성요소중 메서드명과 리턴타입을 제거한다.
구현되는 본문에 리턴이없으면 void고 리턴이 있다면 리턴되는 타입은 이미 정해져 있는 것이므로 생략이 가능하다.

3단계 : 람다문법으로 정리
```java
Thread thread = new Thread(
    () {
        System.out.println("Hello World");
    }
);
```

람다에서는 파라미터 목록을 메서드의 본문으로 전달한다는 의미로 '->' 기호를 사용한다.

4단계 : 최종 결과
```java
Thread thread = new Thread(
    () -> System.out.println("Hello World");
);
```

꼭 필요한것만 남기고 불필요하다고 판단한 부분은 과감히 생략해서 람다표현식으로 정리한 결과가 나온다.

- 정리
1. 익명 클래스를 이용해서 메서드를 정의한다.
2. 익명 클래스를 생성하기 위해서 선언한 인터페이스 이름 부분을 삭제한다. 삭제한 후에는 메서드 선언부분만 남는다.
3. 메서드의 파라미터 목록과 구현한 바디 영역을 제외하고 리턴타입, 메서드명을 삭제한다. 삭제후에는 파라미터 목록과 바디영역만 남는다.
4. 람다 문법에 맞게 -> 를 이용하여 문장을 완성한다.

- 람다표현식의 구성
1. 파라미터 목록 : 메서드의 파라미터 목록을 정의한다.
2. 화살표 : 파라미터 와 코드의 구현 부분을 구분해 준다.
3. 메서드본문 : 파라미터를 받아서 이를 처리하고 결과를 리턴하는 코드영역이다.

[출처] Pratical 모던자바 - 장윤기 지음 

---

### 함수형 인터페이스

람다 표현식을 쓸 수 있는 인터페이스는 오직 public 메서드 하나만 가지고 있는 인터페이스 이여만 한다.
자바8에서 이러한 인터페이스를 특별히 함수형 인터페이스라고 부르고, 함수형 인터페이스에서 제공하는 단 하나의 추상 메서드를 함수형 메서드라고 부른다.

```java

@FunctionalInterface
public interface Consumer<T> {
...
}
```

| 인터페이스명 | 메서드명 | 내용 |
| :--- | :---  | :---  |
| Consumer<T> | void accept(T t) | 파라미터를 전달해서 처리한 후 결과를 리턴받을 필요가 없을때 사용. | 
|  |  | 반기만 하고 리턴하지 않아서 Consumer(소비자)라는 이름을 사용 |
| Function<T, R> | R apply(T t) | 전달할 파라미터를 다른값으로 변환해서 리턴할때 사용. |
|  |  | 주로 값을 변경하거나 매핑할때사용 |
| Predicate<T> | boolean test(T t) | 전달받은 값에 대해 true/false값을 리턴할 때 사용. |
|  |  |  주로 데이터를 필터링하거나 조건에 맞는지 여부를 확인하는 용도로 사용 |
| Supplier<T> | T get() | 파라미터 없이 리턴값만 있는 경우 사용. |
|  |  |  받지는 않고 리턴만 하기 때문에 Supplier(공급자)라는 이름을 사용. |

[출처] Pratical 모던자바 - 장윤기 지음 

---

### Variable Capture

> 람다의 바디에서는 파라미터 말고 바디 외부에 있는 변수를 참조할 수 있다
> 이렇게 람다 시그니처의 파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수를 자유 변수(Free Variable)**라고 부른다.
> 또한 람다 바디에서 **자유 변수를 참조하는 행위를 유식한 말로 **람다 캡처링(Lambda Capturing)**이라고 부른다.

- 제약조건
1. 지역변수를 final로 선언되어야한다.
2. final로 선언되지 않은 지역변수를 final처럼 동작해야한다. -> 값의 재할당이 일어나면 안된다.

[출처] <https://perfectacle.github.io/2019/06/30/java-8-lambda-capturing/>

[출처] Pratical 모던자바 - 장윤기 지음 

---

### 메소드, 생성자 레퍼런스

- 메소드 참조

메서드 참조의 장점은 람다 표현식과는 달리 코드를 여러곳에서 재사용 할수 있고 
자바의 기본 제공 메서드 뿐만 아니라 직접 개발한 메서드도 사용할 수 있다는 점이다.

```java
(String name) -> System.out.println(name)
```

-> 왼쪽에 있는 파라미터는 우리가 이미 알고 있는것. 실제처리해야하는 코드는 오른쪽에 있는 println메서드다 
이것을 메서드 참조 형태로 변경하면 다음과같다. 

```java
System.out::println
```

- 메서드 참조를 정의하는 문법은 2가지
1. 클래스명::메서드명
2. 객체변수명::메서드명

- 생성자 참조

```java
클래스명::new
```

```java
(String name) -> new ConstructorReferenceExample(name)
ConstructorReferenceExample::new
```

생성자 참조는 메서드 참조와 달리 메서드명을 기술하지 않고 new 키워드를 지정
new 라는 문법 자체가 생성자를 호출한다는 의미가 있기 때문에 이문법은 상당히 직관적이고 가독성이 있다.

[출처] Pratical 모던자바 - 장윤기 지음 

